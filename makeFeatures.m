function [ cellMatrix, cellMatrixNoFFT, classification, featsToKeep, normParams, timeCourseInfo ] = makeFeatures( dataSet, cpFeats, thresh, featsToUse, timeCourseInfo, normParams )

% Input: dataSet: .mat file generated by *gather.m
%        cpFeats: Cell Profiler features to use (leave empty to use all)
%        thresh(1): Correlation threshold 1 (features more correlated than this threshold get removed)
%        thresh(2): Correlation threshold 2 (features less correlated with output than this get removed)
%        featsToKeep: Instead of passing 'thresh', specify featsToKeep, a list of featureNames generated by this function
%        timeCourseInfo: list of structs with fieldnames = {'objectSetName', 'cpProperty', 'channelIdx', 'startFrame', 'endFrame'} -- these specify temporal properties you'd like the fft of
%                        set startFrame = endFrame = -1 to use all frames
%        normParams: normalization parameters
%
% Output: cellMatrix
%         cellMatrixNoFFT
%         classification
%         featsToKeep
%         timeCourseInfo (same as input)

addpath(fullfile(fileparts(mfilename('fullpath')),'lib'));

load(dataSet);

makeClassification = 1;
if exist('data', 'var') && ~exist('experiments', 'var')
    experiments = struct('data', data);
    makeClassification = 0;
end

cellMatrix = [];
classification = [];

for expIdx = 1:numel(experiments)
    thisExp = experiments(expIdx);
    if isempty(thisExp.data)
        continue;
    end
    objSetNames = thisExp.data.objectSetNames;
    objMat = [];
    featureNames = {};
    for objIdx = 1:numel(objSetNames)
        objName = objSetNames{objIdx};
        objMats = thisExp.data.(objName);
        cpFeatureNames = fieldnames(objMats);
        removeIdxs = [];
        
        % Cell profiler features appear to start with capital letters
        % so lets not look at things that start with lowercase letters
        for featIdx = 1:numel(cpFeatureNames)
            if isempty(regexp(cpFeatureNames{featIdx}, '^[A-Z]', 'once'))
                removeIdxs = [removeIdxs featIdx];
            end
            if (exist('cpFeats', 'var') && ~isempty(cpFeats)) && ~ismember(cpFeatureNames{featIdx}, cpFeats)
                removeIdxs = [removeIdxs featIdx];
            end
        end
        cpFeatureNames(removeIdxs) = [];
        
        
        for featIdx = 1:numel(cpFeatureNames)
            thisMat = objMats.(cpFeatureNames{featIdx});
            
            for channelIdx = 1:size(thisMat, 3)
                chanName = sprintf('Chan%1d', channelIdx);
                
                thisMatChan = thisMat(:, :, channelIdx);

                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'MissingAtBeginning')];
                missingAtBeg = isnan(thisMatChan(:, 1));
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'Min', chanName)];
                mins = nanmin(thisMatChan(:, :), [], 2);
                mins(isnan(mins)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'Max', chanName)];
                maxs = nanmax(thisMatChan(:, :), [], 2);
                maxs(isnan(maxs)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'Mean', chanName)];
                means = nanmean(thisMatChan(:, :), 2);
                means(isnan(means)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'Std', chanName)];
                stds = nanstd(thisMatChan(:, :), 0, 2);
                stds(isnan(stds)) = 0;

                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'CV', chanName)];
                cv = stds ./ (means + eps);
                
                deriv = diff(thisMatChan, 1, 2);
               
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'derivMin', chanName)];
                derivMin = nanmin(deriv(:, :), [], 2);
                derivMin(isnan(derivMin)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'derivMax', chanName)];
                derivMax = nanmax(deriv(:, :), [], 2);
                derivMax(isnan(derivMax)) = 0;
                              
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'derivMean', chanName)];
                derivMean = nanmean(deriv(:, :), 2);
                derivMean(isnan(derivMean)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'derivStd', chanName)];
                derivStd = nanstd(deriv(:, :), 0, 2);
                derivStd(isnan(derivStd)) = 0;
                
                featureNames = [featureNames; sprintf('%s__%s__%s__%s', objName, cpFeatureNames{featIdx}, 'derivCV', chanName)];
                derivCV = derivStd ./ (derivMean + eps);
                
%                 objMat = [objMat mins maxs means medians stds];
                objMat = [objMat missingAtBeg mins maxs means stds cv derivMin derivMax derivMean derivStd derivCV];
            end
        end
    end
    cellMatrix = [cellMatrix; objMat];
    
    if makeClassification
        prop = thisExp.prop.goodbad.store == 1;
        classification = [classification; prop];
    end
end

if ~exist('featsToUse', 'var') || isempty(featsToUse)
    staticFeatures = max(cellMatrix) == min(cellMatrix);
    
    cellMatrix(:, staticFeatures) = [];
    featureNames(staticFeatures) = [];
    
    corrFeats = abs(corr(cellMatrix)) > thresh(1);
    ignoreMatrix = triu(toeplitz(ones(size(corrFeats, 1), 1)));
    corrFeats = corrFeats .* (1-ignoreMatrix);
    removeFeats = sum(corrFeats, 1) > 0;
    
    cellMatrix(:, removeFeats) = [];
    featureNames(removeFeats) = [];
    
    uncorrFeats = abs(corr(classification, cellMatrix)) < thresh(2);
    removeFeats = uncorrFeats;
    
    cellMatrix(:, removeFeats) = [];
    featureNames(removeFeats) = [];

    featsToKeep = featureNames;

else
    featsToKeep = featsToUse;
    featsToUseIdxs = ismember(featureNames, featsToUse);
    cellMatrix(:, ~featsToUseIdxs) = [];
    featureNames(~featsToUseIdxs) = []; %#ok<NASGU>
end

if ~exist('normParams', 'var') || isempty(normParams)
    divMat = sqrt(sum(cellMatrix.^2, 1));
    cellMatrix = cellMatrix ./ repmat(divMat, size(cellMatrix, 1), 1);
    minVal = min(min(cellMatrix));
    cellMatrix = cellMatrix - minVal + 1e-4;
    normParams = {divMat, minVal};
else
    divMat = normParams{1};
    cellMatrix = cellMatrix ./ repmat(divMat, size(cellMatrix, 1), 1);
    minVal = normParams{2};
    cellMatrix = cellMatrix - minVal + 1e-4;

end





cellMatrixNoFFT = cellMatrix;

for i = 1:numel(timeCourseInfo)
    
    timeCourses = getCpProperty(dataSet, timeCourseInfo(i).objectSetName, timeCourseInfo(i).cpProperty, timeCourseInfo(i).channelIdx);
    
    A = zeros(size(timeCourses));
    for row = 1:size(A, 1)
        A(row, :) = imputeMissing(timeCourses(row, :));
    end
    
    if timeCourseInfo(i).startFrame < 0 || timeCourseInfo(i).endFrame < 0
        F = abs(fft(A, [], 2));
    else
        F = abs(fft(A(:, timeCourseInfo(i).startFrame:timeCourseInfo(i).endFrame), [], 2));
    end
    
    F = F(:, 1:ceil(size(F,2)/2));
    
    cellMatrix = [ cellMatrixNoFFT repmat(isnan(timeCourses(:, 1)), 1, 1) F];
    
end

end

